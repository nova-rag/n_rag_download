Top (Debugging with GDB)
Debugging with GDB
This file documents the GNU debugger GDB.
This is the Tenth Edition, of Debugging with
GDB: the GNU Source-Level Debugger for GDB
(GDB)
Version 17.0.50.20250501-git.
Copyright © 1988-2025 Free Software Foundation, Inc.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being “Free Software” and “Free Software Needs
Free Documentation”, with the Front-Cover Texts being “A GNU Manual,”
and with the Back-Cover Texts as in (a) below.
(a) The FSF’s Back-Cover Text is: “You are free to copy and modify
this GNU Manual.
Buying copies from GNU Press supports the FSF in
developing GNU and promoting software freedom.”
Next: Summary   [Contents][Index]
Debugging with GDB
This file describes GDB, the GNU symbolic debugger.
This is the Tenth Edition, for GDB
(GDB)
Version 17.0.50.20250501-git.
Copyright (C) 1988-2025 Free Software Foundation, Inc.
This edition of the GDB manual is dedicated to the memory of Fred
Fish.
Fred was a long-standing contributor to GDB and to Free
software in general.
We will miss him.
• Summary:  Summary of GDB
• Sample Session:  A sample GDB session
• Invocation:  Getting in and out of GDB
• Commands:  GDB commands
• Running:  Running programs under GDB
• Stopping:  Stopping and continuing
• Reverse Execution:  Running programs backward
• Process Record and Replay:  Recording inferior’s execution and replaying it
• Stack:  Examining the stack
• Source:  Examining source files
• Data:  Examining data
• Optimized Code:  Debugging optimized code
• Macros:  Preprocessor Macros
• Tracepoints:  Debugging remote targets non-intrusively
• Overlays:  Debugging programs that use overlays
• Languages:  Using GDB with different languages
• Symbols:  Examining the symbol table
• Altering:  Altering execution
• GDB Files:  GDB files
• Targets:  Specifying a debugging target
• Remote Debugging:  Debugging remote programs
• Configurations:  Configuration-specific information
• Controlling GDB:  Controlling GDB
• Extending GDB:  Extending GDB
• Interpreters:  Command Interpreters
• TUI:  GDB Text User Interface
• Emacs:  Using GDB under GNU Emacs
• GDB/MI:  GDB’s Machine Interface.
• Annotations:  GDB’s annotation interface.
• Debugger Adapter Protocol:  The Debugger Adapter Protocol.
• JIT Interface:  Using the JIT debugging interface.
• In-Process Agent:  In-Process Agent
• GDB Bugs:  Reporting bugs in GDB
• Command Line Editing:  Command Line Editing
• Using History Interactively:  Using History Interactively
• In Memoriam:  In Memoriam
• Formatting Documentation:  How to format and print GDB documentation
• Installing GDB:  Installing GDB
• Maintenance Commands:  Maintenance Commands
• Remote Protocol:  GDB Remote Serial Protocol
• Agent Expressions:  The GDB Agent Expression Mechanism
• Target Descriptions:  How targets can describe themselves to
GDB
• Operating System Information:  Getting additional information from
the operating system
• Trace File Format:  GDB trace file format
• Index Section Format:  .gdb_index section format
• Debuginfod:  Download debugging resources with debuginfod
• Man Pages:  Manual pages
• Copying:  GNU General Public License says
how you can copy and share GDB
• GNU Free Documentation License:  The license for this documentation
• Concept Index:  Index of GDB concepts
• Command and Variable Index:  Index of GDB commands, variables,
functions, and Python data types
Table of Contents
Summary of GDB
Free Software
Free Software Needs Free Documentation
Contributors to GDB
1 A Sample GDB Session
2 Getting In and Out of GDB
2.1 Invoking GDB
2.1.1 Choosing Files
2.1.2 Choosing Modes
2.1.3 What GDB Does During Startup
2.1.4 Initialization Files
2.1.4.1 Home directory early initialization files
2.1.4.2 System wide initialization files
2.1.4.3 Home directory initialization file
2.1.4.4 Local directory initialization file
2.2 Quitting GDB
2.3 Shell Commands
2.4 Logging Output
3 GDB Commands
3.1 Command Syntax
3.2 Command Settings
3.3 Command Completion
3.4 Filenames As Command Arguments
3.5 Command options
3.6 Getting Help
4 Running Programs Under GDB
4.1 Compiling for Debugging
4.2 Starting your Program
4.3 Your Program’s Arguments
4.4 Your Program’s Environment
4.5 Your Program’s Working Directory
4.6 Your Program’s Input and Output
4.7 Debugging an Already-running Process
4.8 Killing the Child Process
4.9 Debugging Multiple Inferiors Connections and Programs
4.9.1 Inferior-Specific Breakpoints
4.10 Debugging Programs with Multiple Threads
4.11 Debugging Forks
4.12 Setting a Bookmark to Return to Later
4.12.1 A Non-obvious Benefit of Using Checkpoints
5 Stopping and Continuing
5.1 Breakpoints, Watchpoints, and Catchpoints
5.1.1 Setting Breakpoints
5.1.2 Setting Watchpoints
5.1.3 Setting Catchpoints
5.1.4 Deleting Breakpoints
5.1.5 Disabling Breakpoints
5.1.6 Break Conditions
5.1.7 Breakpoint Command Lists
5.1.8 Dynamic Printf
5.1.9 How to save breakpoints to a file
5.1.10 Static Probe Points
5.1.11 “Cannot insert breakpoints”
5.1.12 “Breakpoint address adjusted...”
5.2 Continuing and Stepping
5.3 Skipping Over Functions and Files
5.4 Signals
5.5 Stopping and Starting Multi-thread Programs
5.5.1 All-Stop Mode
5.5.2 Non-Stop Mode
5.5.3 Background Execution
5.5.4 Thread-Specific Breakpoints
5.5.5 Interrupted System Calls
5.5.6 Observer Mode
6 Running programs backward
7 Recording Inferior’s Execution and Replaying It
8 Examining the Stack
8.1 Stack Frames
8.2 Backtraces
8.3 Selecting a Frame
8.4 Information About a Frame
8.5 Applying a Command to Several Frames.
8.6 Management of Frame Filters.
9 Examining Source Files
9.1 Printing Source Lines
9.2 Location Specifications
9.2.1 Linespec Locations
9.2.2 Explicit Locations
9.2.3 Address Locations
9.3 Editing Source Files
9.3.1 Choosing your Editor
9.4 Searching Source Files
9.5 Specifying Source Directories
9.6 Source and Machine Code
9.7 Disable Reading Source Code
10 Examining Data
10.1 Expressions
10.2 Ambiguous Expressions
10.3 Program Variables
10.4 Artificial Arrays
10.5 Output Formats
10.6 Examining Memory
10.7 Memory Tagging
10.8 Automatic Display
10.9 Print Settings
10.10 Pretty Printing
10.10.1 Pretty-Printer Introduction
10.10.2 Pretty-Printer Example
10.10.3 Pretty-Printer Commands
10.11 Value History
10.12 Convenience Variables
10.13 Convenience Functions
10.14 Registers
10.15 Floating Point Hardware
10.16 Vector Unit
10.17 Operating System Auxiliary Information
10.18 Memory Region Attributes
10.18.1 Attributes
10.18.1.1 Memory Access Mode
10.18.1.2 Memory Access Size
10.18.1.3 Data Cache
10.18.2 Memory Access Checking
10.19 Copy Between Memory and a File
10.20 How to Produce a Core File from Your Program
10.21 Character Sets
10.22 Caching Data of Targets
10.23 Search Memory
10.24 Value Sizes
11 Debugging Optimized Code
11.1 Inline Functions
11.2 Tail Call Frames
12 C Preprocessor Macros
13 Tracepoints
13.1 Commands to Set Tracepoints
13.1.1 Create and Delete Tracepoints
13.1.2 Enable and Disable Tracepoints
13.1.3 Tracepoint Passcounts
13.1.4 Tracepoint Conditions
13.1.5 Trace State Variables
13.1.6 Tracepoint Action Lists
13.1.7 Listing Tracepoints
13.1.8 Listing Static Tracepoint Markers
13.1.9 Starting and Stopping Trace Experiments
13.1.10 Tracepoint Restrictions
13.2 Using the Collected Data
13.2.1 tfind n
13.2.2 tdump
13.2.3 save tracepoints filename
13.3 Convenience Variables for Tracepoints
13.4 Using Trace Files
14 Debugging Programs That Use Overlays
14.1 How Overlays Work
14.2 Overlay Commands
14.3 Automatic Overlay Debugging
14.4 Overlay Sample Program
15 Using GDB with Different Languages
15.1 Switching Between Source Languages
15.1.1 List of Filename Extensions and Languages
15.1.2 Setting the Working Language
15.1.3 Having GDB Infer the Source Language
15.2 Displaying the Language
15.3 Type and Range Checking
15.3.1 An Overview of Type Checking
15.3.2 An Overview of Range Checking
15.4 Supported Languages
15.4.1 C and C++
15.4.1.1 C and C++ Operators
15.4.1.2 C and C++ Constants
15.4.1.3 C++ Expressions
15.4.1.4 C and C++ Defaults
15.4.1.5 C and C++ Type and Range Checks
15.4.1.6 GDB and C
15.4.1.7 GDB Features for C++
15.4.1.8 Decimal Floating Point format
15.4.2 D
15.4.3 Go
15.4.4 Objective-C
15.4.4.1 Method Names in Commands
15.4.4.2 The Print Command With Objective-C
15.4.5 OpenCL C
15.4.5.1 OpenCL C Datatypes
15.4.5.2 OpenCL C Expressions
15.4.5.3 OpenCL C Operators
15.4.6 Fortran
15.4.6.1 Fortran Types
15.4.6.2 Fortran Operators and Expressions
15.4.6.3 Fortran Intrinsics
15.4.6.4 Special Fortran Commands
15.4.7 Pascal
15.4.8 Rust
15.4.9 Modula-2
15.4.9.1 Operators
15.4.9.2 Built-in Functions and Procedures
15.4.9.3 Constants
15.4.9.4 Modula-2 Types
15.4.9.5 Modula-2 Defaults
15.4.9.6 Deviations from Standard Modula-2
15.4.9.7 Modula-2 Type and Range Checks
15.4.9.8 The Scope Operators :: and .
15.4.9.9 GDB and Modula-2
15.4.10 Ada
15.4.10.1 Introduction
15.4.10.2 Omissions from Ada
15.4.10.3 Additions to Ada
15.4.10.4 Overloading support for Ada
15.4.10.5 Stopping at the Very Beginning
15.4.10.6 Ada Exceptions
15.4.10.7 Extensions for Ada Tasks
15.4.10.8 Tasking Support when Debugging Core Files
15.4.10.9 Tasking Support when using the Ravenscar Profile
15.4.10.10 Ada Source Character Set
15.4.10.11 Known Peculiarities of Ada Mode
15.5 Unsupported Languages
16 Examining the Symbol Table
17 Altering Execution
17.1 Assignment to Variables
17.2 Continuing at a Different Address
17.3 Giving your Program a Signal
17.4 Returning from a Function
17.5 Calling Program Functions
17.5.1 Calling functions with no debug info
17.6 Patching Programs
17.7 Compiling and injecting code in GDB
17.7.1 Compilation options for the compile command
17.7.2 Caveats when using the compile command
17.7.3 Compiler search for the compile command
18 GDB Files
18.1 Commands to Specify Files
18.2 File Caching
18.3 Debugging Information in Separate Files
18.4 Debugging information in a special section
18.5 Index Files Speed Up GDB
18.5.1 Automatic symbol index cache
18.5.2 Building the index with GNU gold
18.6 Extensions to ‘.debug_names’
18.7 Errors Reading Symbol Files
18.8 GDB Data Files
19 Specifying a Debugging Target
19.1 Active Targets
19.2 Commands for Managing Targets
19.3 Choosing Target Byte Order
20 Debugging Remote Programs
20.1 Connecting to a Remote Target
20.1.1 Types of Remote Connections
20.1.2 Host and Target Files
20.1.3 Remote Connection Commands
20.2 Sending files to a remote system
20.3 Using the gdbserver Program
20.3.1 Running gdbserver
20.3.1.1 Attaching to a Running Program
20.3.1.2 TCP port allocation lifecycle of gdbserver
20.3.1.3 Other Command-Line Arguments for gdbserver
20.3.2 Connecting to gdbserver
20.3.3 Monitor Commands for gdbserver
20.3.4 Tracepoints support in gdbserver
20.4 Remote Configuration
20.5 Implementing a Remote Stub
20.5.1 What the Stub Can Do for You
20.5.2 What You Must Do for the Stub
20.5.3 Putting it All Together
21 Configuration-Specific Information
21.1 Native
21.1.1 BSD libkvm Interface
21.1.2 Process Information
21.1.3 Features for Debugging DJGPP Programs
21.1.4 Features for Debugging MS Windows PE Executables
21.1.4.1 Support for DLLs without Debugging Symbols
21.1.4.2 DLL Name Prefixes
21.1.4.3 Working with Minimal Symbols
21.1.5 Commands Specific to GNU Hurd Systems
21.1.6 Darwin
21.1.7 FreeBSD
21.2 Embedded Operating Systems
21.3 Embedded Processors
21.3.1 Synopsys ARC
21.3.2 ARM
21.3.3 BPF
21.3.4 M68k
21.3.5 MicroBlaze
21.3.6 MIPS Embedded
21.3.7 OpenRISC 1000
21.3.8 PowerPC Embedded
21.3.9 Atmel AVR
21.3.10 CRIS
21.3.11 Renesas Super-H
21.4 Architectures
21.4.1 AArch64
21.4.1.1 AArch64 SVE.
21.4.1.2 AArch64 SME.
21.4.1.3 AArch64 SME2.
21.4.1.4 AArch64 Pointer Authentication.
21.4.1.5 AArch64 Memory Tagging Extension.
21.4.2 x86
21.4.2.1 x87 registers
21.4.3 Alpha
21.4.4 MIPS
21.4.5 HPPA
21.4.6 PowerPC
21.4.7 Sparc64
21.4.7.1 ADI Support
21.4.8 S12Z
21.4.9 AMD GPU
21.4.9.1 AMD GPU Architectures
21.4.9.2 AMD GPU Device Driver and AMD ROCm Runtime
21.4.9.3 AMD GPU Wavefronts
21.4.9.4 AMD GPU Code Objects
21.4.9.5 AMD GPU Entity Target Identifiers and Convenience Variables
21.4.9.6 AMD GPU Signals
21.4.9.7 AMD GPU Memory Violation Reporting
21.4.9.8 AMD GPU Logging
21.4.9.9 AMD GPU Restrictions
21.4.10 RISC-V
22 Controlling GDB
22.1 Prompt
22.2 Command Editing
22.3 Command History
22.4 Screen Size
22.5 Output Styling
22.6 Numbers
22.7 Configuring the Current ABI
22.8 Automatically loading associated files
22.8.1 Automatically loading init file in the current directory
22.8.2 Automatically loading thread debugging library
22.8.3 Security restriction for auto-loading
22.8.4 Displaying files tried for auto-load
22.9 Optional Warnings and Messages
22.10 Optional Messages about Internal Happenings
22.11 Other Miscellaneous Settings
23 Extending GDB
23.1 Canned Sequences of Commands
23.1.1 User-defined Commands
23.1.2 User-defined Command Hooks
23.1.3 Command Files
23.1.4 Commands for Controlled Output
23.1.5 Controlling auto-loading native GDB scripts
23.2 Command Aliases
23.2.1 Default Arguments
23.3 Extending GDB using Python
23.3.1 Python Commands
23.3.2 Python API
23.3.2.1 Basic Python
23.3.2.2 Threading in GDB
23.3.2.3 Exception Handling
23.3.2.4 Values From Inferior
23.3.2.5 Types In Python
23.3.2.6 Pretty Printing API
23.3.2.7 Selecting Pretty-Printers
23.3.2.8 Writing a Pretty-Printer
23.3.2.9 Type Printing API
23.3.2.10 Filtering Frames
23.3.2.11 Decorating Frames
23.3.2.12 Writing a Frame Filter
23.3.2.13 Unwinding Frames in Python
23.3.2.14 Xmethods In Python
23.3.2.15 Xmethod API
23.3.2.16 Writing an Xmethod
23.3.2.17 Inferiors In Python
23.3.2.18 Events In Python
23.3.2.19 Threads In Python
23.3.2.20 Recordings In Python
23.3.2.21 CLI Commands In Python
23.3.2.22 GDB/MI Commands In Python
23.3.2.23 GDB/MI Notifications In Python
23.3.2.24 Parameters In Python
23.3.2.25 Writing new convenience functions
23.3.2.26 Program Spaces In Python
23.3.2.27 Objfiles In Python
23.3.2.28 Accessing inferior stack frames from Python
23.3.2.29 Accessing blocks from Python
23.3.2.30 Python representation of Symbols
23.3.2.31 Symbol table representation in Python
23.3.2.32 Manipulating line tables using Python
23.3.2.33 Manipulating breakpoints using Python
23.3.2.34 Finish Breakpoints
23.3.2.35 Python representation of lazy strings
23.3.2.36 Python representation of colors
23.3.2.37 Python representation of architectures
23.3.2.38 Registers In Python
23.3.2.39 Connections In Python
23.3.2.40 Implementing new TUI windows
23.3.2.41 Instruction Disassembly In Python
23.3.2.42 Missing Debug Info In Python
23.3.2.43 Missing Objfiles In Python
23.3.3 Python Auto-loading
23.3.4 Python modules
23.3.4.1 gdb.printing
23.3.4.2 gdb.types
23.3.4.3 gdb.prompt
23.3.4.4 gdb.ptwrite
23.4 Extending GDB using Guile
23.4.1 Guile Introduction
23.4.2 Guile Commands
23.4.3 Guile API
23.4.3.1 Basic Guile
23.4.3.2 Guile Configuration
23.4.3.3 GDB Scheme Data Types
23.4.3.4 Guile Exception Handling
23.4.3.5 Values From Inferior In Guile
23.4.3.6 Arithmetic In Guile
23.4.3.7 Types In Guile
23.4.3.8 Guile Pretty Printing API
23.4.3.9 Selecting Guile Pretty-Printers
23.4.3.10 Writing a Guile Pretty-Printer
23.4.3.11 Commands In Guile
23.4.3.12 Parameters In Guile
23.4.3.13 Program Spaces In Guile
23.4.3.14 Objfiles In Guile
23.4.3.15 Accessing inferior stack frames from Guile.
23.4.3.16 Accessing blocks from Guile.
23.4.3.17 Guile representation of Symbols.
23.4.3.18 Symbol table representation in Guile.
23.4.3.19 Manipulating breakpoints using Guile
23.4.3.20 Guile representation of lazy strings.
23.4.3.21 Guile representation of architectures
23.4.3.22 Disassembly In Guile
23.4.3.23 I/O Ports in Guile
23.4.3.24 Memory Ports in Guile
23.4.3.25 Iterators In Guile
23.4.3.26 Colors In Guile
23.4.4 Guile Auto-loading
23.4.5 Guile Modules
23.4.5.1 Guile Printing Module
23.4.5.2 Guile Types Module
23.5 Auto-loading extensions
23.5.1 The objfile-gdb.ext file
23.5.2 The .debug_gdb_scripts section
23.5.2.1 Script File Entries
23.5.2.2 Script Text Entries
23.5.3 Which flavor to choose?
23.6 Multiple Extension Languages
23.6.1 Python comes first
24 Command Interpreters
25 GDB Text User Interface
25.1 TUI Overview
25.2 TUI Key Bindings
25.3 TUI Single Key Mode
25.4 TUI Mouse Support
25.5 TUI-specific Commands
25.6 TUI Configuration Variables
26 Using GDB under GNU Emacs
27 The GDB/MI Interface
Function and Purpose
Notation and Terminology
27.1 GDB/MI General Design
27.1.1 Context management
27.1.1.1 Threads and Frames
27.1.1.2 Language
27.1.2 Asynchronous command execution and non-stop mode
27.1.3 Thread groups
27.2 GDB/MI Command Syntax
27.2.1 GDB/MI Input Syntax
27.2.2 GDB/MI Output Syntax
27.3 GDB/MI Compatibility with CLI
27.4 GDB/MI Development and Front Ends
27.5 GDB/MI Output Records
27.5.1 GDB/MI Result Records
27.5.2 GDB/MI Stream Records
27.5.3 GDB/MI Async Records
27.5.4 GDB/MI Breakpoint Information
27.5.5 GDB/MI Frame Information
27.5.6 GDB/MI Thread Information
27.5.7 GDB/MI Ada Exception Information
27.6 Simple Examples of GDB/MI Interaction
27.7 GDB/MI Command Description Format
27.8 GDB/MI Breakpoint Commands
27.9 GDB/MI Catchpoint Commands
27.9.1 Shared Library GDB/MI Catchpoints
27.9.2 Ada Exception GDB/MI Catchpoints
27.9.3 C++ Exception GDB/MI Catchpoints
27.10 GDB/MI
Program Context
27.11 GDB/MI Thread Commands
27.12 GDB/MI Ada Tasking Commands
27.13 GDB/MI Program Execution
27.14 GDB/MI Stack Manipulation Commands
27.15 GDB/MI Variable Objects
27.16 GDB/MI Data Manipulation
27.17 GDB/MI Tracepoint Commands
27.18 GDB/MI Symbol Query Commands
27.19 GDB/MI File Commands
27.20 GDB/MI Target Manipulation Commands
27.21 GDB/MI File Transfer Commands
27.22 Ada Exceptions GDB/MI Commands
27.23 GDB/MI Support Commands
27.24 Miscellaneous GDB/MI Commands
28 GDB Annotations
28.1 What is an Annotation?
28.2 The Server Prefix
28.3 Annotation for GDB Input
28.4 Errors
28.5 Invalidation Notices
28.6 Running the Program
28.7 Displaying Source
29 Debugger Adapter Protocol
30 JIT Compilation Interface
30.1 JIT Declarations
30.2 Registering Code
30.3 Unregistering Code
30.4 Custom Debug Info
30.4.1 Using JIT Debug Info Readers
30.4.2 Writing JIT Debug Info Readers
31 In-Process Agent
31.1 In-Process Agent Protocol
31.1.1 IPA Protocol Objects
31.1.2 IPA Protocol Commands
32 Reporting Bugs in GDB
32.1 Have You Found a Bug?
32.2 How to Report Bugs
33 Command Line Editing
33.1 Introduction to Line Editing
33.2 Readline Interaction
33.2.1 Readline Bare Essentials
33.2.2 Readline Movement Commands
33.2.3 Readline Killing Commands
33.2.4 Readline Arguments
33.2.5 Searching for Commands in the History
33.3 Readline Init File
33.3.1 Readline Init File Syntax
33.3.2 Conditional Init Constructs
33.3.3 Sample Init File
33.4 Bindable Readline Commands
33.4.1 Commands For Moving
33.4.2 Commands For Manipulating The History
33.4.3 Commands For Changing Text
33.4.4 Killing And Yanking
33.4.5 Specifying Numeric Arguments
33.4.6 Letting Readline Type For You
33.4.7 Keyboard Macros
33.4.8 Some Miscellaneous Commands
33.5 Readline vi Mode
34 Using History Interactively
34.1 History Expansion
34.1.1 Event Designators
34.1.2 Word Designators
34.1.3 Modifiers
Appendix A In Memoriam
Appendix B Formatting Documentation
Appendix C Installing GDB
C.1 Requirements for Building GDB
C.2 Invoking the GDB configure Script
C.3 Compiling GDB in Another Directory
C.4 Specifying Names for Hosts and Targets
C.5 configure Options
C.6 System-wide configuration and settings
C.6.1 Installed System-wide Configuration Scripts
Appendix D Maintenance Commands
Appendix E GDB Remote Serial Protocol
E.1 Overview
E.2 Standard Replies
E.3 Packets
E.4 Stop Reply Packets
E.5 General Query Packets
E.6 Architecture-Specific Protocol Details
E.6.1 ARM-specific Protocol Details
E.6.1.1 ARM Breakpoint Kinds
E.6.1.2 ARM Memory Tag Types
E.6.2 MIPS-specific Protocol Details
E.6.2.1 MIPS Register Packet Format
E.6.2.2 MIPS Breakpoint Kinds
E.7 Tracepoint Packets
E.7.1 Relocate instruction reply packet
E.8 Host I/O Packets
E.9 Interrupts
E.10 Notification Packets
E.11 Remote Protocol Support for Non-Stop Mode
E.12 Packet Acknowledgment
E.13 Examples
E.14 File-I/O Remote Protocol Extension
E.14.1 File-I/O Overview
E.14.2 Protocol Basics
E.14.3 The F Request Packet
E.14.4 The F Reply Packet
E.14.5 The ‘Ctrl-C’ Message
E.14.6 Console I/O
E.14.7 List of Supported Calls
open
close
read
write
lseek
rename
unlink
stat/fstat
gettimeofday
isatty
system
E.14.8 Protocol-specific Representation of Datatypes
Integral Datatypes
Pointer Values
Memory Transfer
struct stat
struct timeval
E.14.9 Constants
Open Flags
mode_t Values
Errno Values
Lseek Flags
Limits
E.14.10 File-I/O Examples
E.15 Library List Format
E.16 Library List Format for SVR4 Targets
E.17 Memory Map Format
E.18 Thread List Format
E.19 Traceframe Info Format
E.20 Branch Trace Format
E.21 Branch Trace Configuration Format
Appendix F The GDB Agent Expression Mechanism
F.1 General Bytecode Design
F.2 Bytecode Descriptions
F.3 Using Agent Expressions
F.4 Varying Target Capabilities
F.5 Rationale
Appendix G Target Descriptions
G.1 Retrieving Descriptions
G.2 Target Description Format
G.2.1 Inclusion
G.2.2 Architecture
G.2.3 OS ABI
G.2.4 Compatible Architecture
G.2.5 Features
G.2.6 Types
G.2.7 Registers
G.3 Predefined Target Types
G.4 Enum Target Types
G.5 Standard Target Features
G.5.1 AArch64 Features
G.5.1.1 AArch64 core registers feature
G.5.1.2 AArch64 floating-point registers feature
G.5.1.3 AArch64 SVE registers feature
G.5.1.4 AArch64 Pointer Authentication registers feature
G.5.1.5 AArch64 TLS registers feature
G.5.1.6 AArch64 MTE registers feature
G.5.1.7 AArch64 SME registers feature
G.5.1.8 AArch64 SME2 registers feature
G.5.2 ARC Features
G.5.3 ARM Features
G.5.3.1 Core register set for non-M-profile
G.5.3.2 Core register set for M-profile
G.5.3.3 FPA registers feature (obsolete)
G.5.3.4 M-profile Vector Extension (MVE)
G.5.3.5 XScale iwMMXt feature
G.5.3.6 Vector Floating-Point (VFP) feature
G.5.3.7 NEON architecture feature
G.5.3.8 M-profile Pointer Authentication and Branch Target Identification feature
G.5.3.9 M-profile system registers feature
G.5.3.10 M-profile Security Extensions feature
G.5.3.11 TLS registers feature
G.5.4 i386 Features
G.5.5 LoongArch Features
G.5.6 MicroBlaze Features
G.5.7 MIPS Features
G.5.8 M68K Features
G.5.9 NDS32 Features
G.5.10 Openrisc 1000 Features
G.5.11 PowerPC Features
G.5.12 RISC-V Features
G.5.13 RX Features
G.5.14 S/390 and System z Features
G.5.15 Sparc Features
G.5.16 TMS320C6x Features
Appendix H Operating System Information
H.1 Process list
Appendix I Trace File Format
Appendix J .gdb_index section format
Appendix K Download debugging resources with Debuginfod
K.1 Debuginfod Settings
Appendix L Manual pages
Appendix M GNU GENERAL PUBLIC LICENSE
Appendix N GNU Free Documentation License
Concept Index
Command, Variable, and Function Index
Next: Summary   [Contents][Index]